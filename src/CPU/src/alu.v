//
// Generated by Bluespec Compiler (build 0000000)
//
// On Sat Nov 28 22:16:41 PST 2020
//
//
// Ports:
// Name                         I/O  size props
// RDY_getData                    O     1 const
// exec                           O     8 reg
// RDY_exec                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// getData_i_A                    I     8 reg
// getData_i_B                    I     8 reg
// exec_i_INST                    I     4
// EN_getData                     I     1
// EN_exec                        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module alu(CLK,
	   RST_N,

	   getData_i_A,
	   getData_i_B,
	   EN_getData,
	   RDY_getData,

	   exec_i_INST,
	   EN_exec,
	   exec,
	   RDY_exec);
  input  CLK;
  input  RST_N;

  // action method getData
  input  [7 : 0] getData_i_A;
  input  [7 : 0] getData_i_B;
  input  EN_getData;
  output RDY_getData;

  // actionvalue method exec
  input  [3 : 0] exec_i_INST;
  input  EN_exec;
  output [7 : 0] exec;
  output RDY_exec;

  // signals for module outputs
  wire [7 : 0] exec;
  wire RDY_exec, RDY_getData;

  // register r_OP1
  reg [7 : 0] r_OP1;
  wire [7 : 0] r_OP1$D_IN;
  wire r_OP1$EN;

  // register r_OP2
  reg [7 : 0] r_OP2;
  wire [7 : 0] r_OP2$D_IN;
  wire r_OP2$EN;

  // register r_RES
  reg [7 : 0] r_RES;
  reg [7 : 0] r_RES$D_IN;
  wire r_RES$EN;

  // remaining internal signals
  wire [15 : 0] r_OP1_9_MUL_r_OP2_0___d23;
  wire [7 : 0] x__h263, x__h298, x__h351, x__h379, x__h397, x__h415;

  // action method getData
  assign RDY_getData = 1'd1 ;

  // actionvalue method exec
  assign exec = r_RES ;
  assign RDY_exec = 1'd1 ;

  // register r_OP1
  assign r_OP1$D_IN = getData_i_A ;
  assign r_OP1$EN = EN_getData ;

  // register r_OP2
  assign r_OP2$D_IN = getData_i_B ;
  assign r_OP2$EN = EN_getData ;

  // register r_RES
  always@(exec_i_INST or
	  x__h415 or
	  r_RES or
	  x__h263 or
	  x__h298 or
	  r_OP1_9_MUL_r_OP2_0___d23 or x__h351 or x__h379 or x__h397)
  begin
    case (exec_i_INST)
      4'd0, 4'd4: r_RES$D_IN = r_RES;
      4'd1: r_RES$D_IN = x__h263;
      4'd2: r_RES$D_IN = x__h298;
      4'd3: r_RES$D_IN = r_OP1_9_MUL_r_OP2_0___d23[7:0];
      4'd5: r_RES$D_IN = x__h351;
      4'd6: r_RES$D_IN = x__h379;
      4'd7: r_RES$D_IN = x__h397;
      default: r_RES$D_IN = x__h415;
    endcase
  end
  assign r_RES$EN =
	     EN_exec &&
	     (exec_i_INST == 4'd0 || exec_i_INST == 4'd1 ||
	      exec_i_INST == 4'd2 ||
	      exec_i_INST == 4'd3 ||
	      exec_i_INST == 4'd4 ||
	      exec_i_INST == 4'd5 ||
	      exec_i_INST == 4'd6 ||
	      exec_i_INST == 4'd7 ||
	      exec_i_INST == 4'd8) ;

  // remaining internal signals
  assign r_OP1_9_MUL_r_OP2_0___d23 = r_OP1 * r_OP2 ;
  assign x__h263 = r_OP1 + r_OP2 ;
  assign x__h298 = r_OP1 - r_OP2 ;
  assign x__h351 = r_OP1 & r_OP2 ;
  assign x__h379 = r_OP1 | r_OP2 ;
  assign x__h397 = r_OP1 ^ r_OP2 ;
  assign x__h415 = ~r_OP1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        r_OP1 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	r_OP2 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	r_RES <= `BSV_ASSIGNMENT_DELAY 8'd0;
      end
    else
      begin
        if (r_OP1$EN) r_OP1 <= `BSV_ASSIGNMENT_DELAY r_OP1$D_IN;
	if (r_OP2$EN) r_OP2 <= `BSV_ASSIGNMENT_DELAY r_OP2$D_IN;
	if (r_RES$EN) r_RES <= `BSV_ASSIGNMENT_DELAY r_RES$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    r_OP1 = 8'hAA;
    r_OP2 = 8'hAA;
    r_RES = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // alu

